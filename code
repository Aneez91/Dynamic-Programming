
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Scanner;
import java.util.Set;
import java.util.Stack;
 
class Vertex
{
	public int label; // label (e.g. 'A')
	public boolean wasVisited;
	public Vertex(int lab) // constructor
	{
		label = lab;
		wasVisited = false;
	}
}  

class Graph
{
	private   int MAX_VERTS = 20;
	private Vertex vertexList[]; // array of vertices
	private int adjMat[][]; // adjacency matrix
	private int nVerts; // current number of vertices
	Stack<Integer>  theStack=new Stack(); 
	Queue<Integer> theQueue=new  PriorityQueue<Integer>();
	private int sortedArray[];
	static Set <Integer>s=new HashSet<Integer>(); 
	public Graph(int MAX_VERTS) // constructor
	{
		this.MAX_VERTS=MAX_VERTS;
		vertexList = new Vertex[MAX_VERTS+1];
		// adjacency matrix
		adjMat = new int[MAX_VERTS][MAX_VERTS];
		sortedArray=new int[MAX_VERTS];
		nVerts = 0;
		for(int j=0; j<MAX_VERTS; j++) // set adjacency
			for(int k=0; k<MAX_VERTS; k++) // matrix to 0
				adjMat[j][k] = 0;
	} // end constructor
	// ------------------------------------------------------------
	public void addVertex(int lab) // argument is label
	{
		vertexList[nVerts++] = new Vertex(lab);
	}
	// ------------------------------------------------------------
	public void addEdge(int start, int end)
	{
	adjMat[start][end] = 1;
	}
	// ------------------------------------------------------------
	public void displayVertex(int v)
	{
		System.out.print(vertexList[v].label);
	}
	// ------------------------------------------------------------
	public int getAdjUnvisitedVertex(int v)
	{
	for(int j=0; j<nVerts; j++)
	if(adjMat[v][j]==1 && vertexList[j].wasVisited==false)
	return j; // return first such vertex
	return -1; // no such vertices
	}
	
	public int dfs(List<Integer> val) // depth-first search
	{ // begin at vertex 0
		vertexList[val.get(0)].wasVisited = true; // mark it
		//displayVertex(0); // display it
		theStack.push(val.get(0)); // push it
		int max=1;
		 
		if( noSuccessors()==-1) {
			System.out.println("gfgybh");
		 return -1;
		}
		while( !theStack.isEmpty() ) // until stack empty,
		{
				// get an unvisited vertex adjacent to stack top
			int v = getAdjUnvisitedVertex( theStack.peek() );
			if(v == -1) {// if no such vertex,
				if(max<theStack.size())
					max=theStack.size();
				val.remove( theStack.pop()); 
			}// pop a new one
			else // if it exists,
			{
				vertexList[v].wasVisited = true; // mark it
				//displayVertex(v); // display it
				theStack.push(v); // push it
			}
		} // end while
		// stack is empty, so we're done
		for(int j=0; j<nVerts; j++) // reset flags
			vertexList[j].wasVisited = false;
		return max;
	}
	
	public void bfs() // breadth-first search
	{ // begin at vertex 0
		vertexList[0].wasVisited = true; // mark it
		displayVertex(0); // display it
		theQueue.add(0); // insert at tail
		int v2;
		while( !theQueue.isEmpty() ) // until queue empty,
		{
		
			int v1 = theQueue.peek() ; // remove vertex at head
			// until it has no unvisited neighbors
		 
			while( (v2=getAdjUnvisitedVertex(v1)) != -1 )
			{ // get one,
				vertexList[v2].wasVisited = true; // mark it
				displayVertex(v2); // display it
				theQueue.add(v2); // insert it
			} // end while(unvisited neighbors)
		} // end while(queue not empty)
		// queue is empty, so we're done
		for(int j=0; j<nVerts; j++) // reset flags
			vertexList[j].wasVisited = false;
	}
	
	public void topo() // toplogical sort
	{
	int orig_nVerts = nVerts; // remember how many verts
	while(nVerts > 0) // while vertices remain,
	{
	// get a vertex with no successors, or -1
	int currentVertex = noSuccessors();
	if(currentVertex == -1) // must be a cycle
	{
	System.out.println("ERROR: Graph has cycles");
	return;
	}
	// insert vertex label in sorted array (start at end)
	sortedArray[nVerts-1] = vertexList[currentVertex].label;// currentVertex;
	deleteVertex(currentVertex); // delete vertex
	} // end while
	// vertices all gone; display sortedArray
	System.out.print("Topologically sorted order: ");
	for(int j=0; j<orig_nVerts; j++)
	System.out.print( sortedArray[j] );
	System.out.println("");
	}
	
	public int noSuccessors() // returns vert with no
 
	{ // (or -1 if no such verts)
	boolean isEdge; // edge from row to column in adjMat
	for(int row=0; row<nVerts; row++) // for each vertex,
	{
	isEdge = false; // check edges
	for(int col=0; col<nVerts; col++)
	{
	if( adjMat[row][col] > 0 ) // if edge to
	{ // another,
	isEdge = true;
	break; // this vertex
	} // has a successor
	} // try another
	if( !isEdge ) // if no edges,
	return row; // has no
	}
	return -1; // no such vertex
	}
	
	public void deleteVertex(int delVert)
	{
	if(delVert != nVerts-1) // if not last vertex,
	{ // delete from vertexList
	for(int j=delVert; j<nVerts-1; j++)
	vertexList[j] = vertexList[j+1];
	// delete row from adjMat
	for(int row=delVert; row<nVerts-1; row++)
	moveRowUp(row, nVerts);
	// delete col from adjMat
	for(int col=delVert; col<nVerts-1; col++)
	moveColLeft(col, nVerts-1);
	}
	nVerts--; // one less vertex
	}
	
	private void moveRowUp(int row, int length)
	{
	for(int col=0; col<length; col++)
	adjMat[row][col] = adjMat[row+1][col];
	}
	private void moveColLeft(int col, int length)
	{
	for(int row=0; row<length; row++)
	adjMat[row][col] = adjMat[row][col+1];
	}
	
	
	public int bfs_groupofFriends(int vert ) // breadth-first search
	{ // begin at vertex 0
		if( vertexList[vert].wasVisited)
			return 0;
		vertexList[vert].wasVisited = true; // mark it
		int i=1;
		displayVertex(vert); // display it
		theQueue.add(vert); // insert at tail
		int v2;
		while( !theQueue.isEmpty() ) // until queue empty,
		{
			 
			int v1 = theQueue.poll() ; // remove vertex at head
			// until it has no unvisited neighbors
		 
			while( (v2=getAdjUnvisitedVertex(v1)) != -1 )
			{ // get one,
				i++;
				vertexList[v2].wasVisited = true; // mark it
				displayVertex(v2); // display it
				theQueue.add(v2); // insert it
			} // end while(unvisited neighbors)
		} // end while(queue not empty)
		// queue is empty, so we're done
/*		for(int j=0; j<nVerts; j++) // reset flags
			vertexList[j].wasVisited = false;
*/		return i;
	}
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int T = in.nextInt();
		int i1=1;
		while (T-- > 0) {
			s=new HashSet<Integer>();
			int n = in.nextInt();
			int edges= in.nextInt();
			Graph theGraph = new Graph(n);
			for(int i=0;i<n;i++)
				theGraph.addVertex(i);
			while(edges-->0){
				int a=in.nextInt();
			theGraph.addEdge(a, in.nextInt());
			s.add(a);
			}
			//theGraph.topo();
			 List <Integer>lis=new ArrayList<Integer>(s);
			//Iterator <Integer>it=s.iterator();
			int val=-2,max=0;
			while(lis.size()!=0){
			  val=theGraph.dfs(lis );
			  if(val==-1)
				  break;
			  if(max<val)
				  max=val;
			}
			if(val==-1)
			System.out.println("Case "+(i1++)+": Never Ends");
			else{
				 
				System.out.println("Case "+(i1++)+": "+(max ) +" semester(s)");
			}
				
		}
	}
}
public class Friends1 {
	public static void main(String[] args) {
		
		 
		 Scanner sc=new Scanner(System.in );
	     int n=sc.nextInt();
	     int friendsgroup=sc.nextInt();
	     Graph theGraph = new Graph(n+1);
	     List <Integer> list=new ArrayList<Integer>(); 
			int i=0;
	     while(i++<=n-1){
	    	 list.add(i);
	    	 theGraph.addVertex(i);
	     }
	     while(friendsgroup-->0)
	    		theGraph.addEdge(sc.nextInt(), sc.nextInt());
	     int sum=0;
	     for(Integer i1:list){
	    	 int val=theGraph.bfs_groupofFriends(i1-1);
	    	 if(val>0)
	    		 sum+=Math.sqrt(val);
	    	 System.out.println(val ); 
	     }
	     System.out.println(sum);
			
	}
}
